№1
Тип std::pair - это тип данных для группировки двух значений вместе как один объект. Его удобно использовать, например, для задания точек на плоскости, либо для задания имени и фамилии человека и дальнейшего использования pair как одного объекта
Тип std::tuple аналогичен std::pair, но позволяет группировать более 2-х значений. Удобен для задания точек многомерного пространства, при создании таблицы с данными группы людей (ФИО, возраст, пол и т.д.)

№2
std::array - статический массив, контейнер с постоянным числом элементов. Используется в случаях, когда: 1)количество элементов известно при создании массива, 2)количество элементов постоянно

№3
std::vector - динамический массив, контейнер для хранения переменного числа элементов. В отличие от статического массива, может быть расширен/уменьшен в процессе работы программы.

№4
std::deque  — двусторонняя очередь. Контейнер deque похож на контейнер std::vector (также как и std::vector, std::deque является динамическим массивом). Разница между std::vector и std::deque состоит в том, что в std::deque добавлять новые элементы можно как в конец, так и в начало контейнера.

№5
std::list - структура данных, которая построена на двусвязных списках. Это значит, что любой элемент знает только о предыдущем и о следующем элементах. Контейнер std::list используют из-за быстрого добавления и удаление значений. Это происходит так быстро, потому что не приходиться перемещать элементы между собой, нужно лишь правильно манипулировать указателями.

№6
std::forward_list - односвязный список. Отличается от std::list лишь отсутствием обратной связи.

№7
1)stack — это контейнерный класс, элементы которого работают по следующему принципу: элементы добавляются в конец контейнера и удаляются оттуда же.
2)queue — это контейнерный класс, элементы которого работают по следующему принципу: элементы добавляются в конец контейнера, но удаляются из начала контейнера.
3)priority_queue — это тип очереди, в которой все элементы отсортированы (с помощью оператора сравнения <). При добавлении элемента, он автоматически сортируется. Элемент с наивысшим приоритетом (самый большой элемент) находится в самом начале очереди с приоритетом, также, как и удаление элементов выполняется с самого начала очереди с приоритетом.

№8
boost::circular_buffer удобно использовать в том случае, когда необходимо хранить некоторые данные, которые со временем теряют свою значимость. Добавляющиеся новые объекты попадают в конец очереди, и при достижении заранее заданного максимального количества объектов старые данные из начала контейнера будут заменяться новыми данными.

№9
Контейнер boost::circular_buffer не может войти в стандарт из-за условия v.begin() != v.end()

№10
Для работы с многомерными массивами подходят следующие типы данных (контейнеры): boost::multi_array, многомерный массив (arr[][]) из С, векторы. 